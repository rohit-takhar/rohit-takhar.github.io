[{"authors":["Rohit Takhar","Varun Aggarwal"],"categories":null,"content":"More detail can easily be written here using Markdown and $\\rm \\LaTeX$ math code.\n","date":1540751400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1540751400,"objectID":"de92cbf49e79f776ab136d1b5c433a4c","permalink":"https://rohit-takhar.github.io/publication/grade-uncompilable/","publishdate":"2018-10-29T00:00:00+05:30","relpermalink":"/publication/grade-uncompilable/","section":"publication","summary":"We present the first approach to grade uncompilable codes and provide semantic feedback on them using machine learning. We propose two methods that allow us to derive informative semantic features from programs. One of this approach makes the program compilable by correcting errors, while the other relaxes syntax/grammar rules to help parse uncompilable codes. We compare the relative efficacy of these approaches towards grading. We finally combine them to build an algorithm which rivals the accuracy of experts in grading programs. Additionally, we show that the models learned for compilable codes can be reused for uncompilable codes. We present a case study, where a company is able to hire more efficiently by deploying our technology.","tags":[],"title":"Grading uncompilable programs","type":"publication"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;\n","date":1536431400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1536431400,"objectID":"6a451186c775f5f0adb3a0416d0cb711","permalink":"https://rohit-takhar.github.io/tutorial/example/","publishdate":"2018-09-09T00:00:00+05:30","relpermalink":"/tutorial/example/","section":"tutorial","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 \u0026hellip;\nTip 2 \u0026hellip;","tags":null,"title":"Example Page","type":"docs"},{"authors":null,"categories":null,"content":" OSAVA visualizes the different types of algorithms used in operating systems as given in Silberschatz et al. (2012). OSAVA has six modules each dedicated to a particular type of algorithm. A module asks the user to select one of the algorithms available in it and enter relevant information. The module displays a brief description of the selected algorithm and then simulates its working. Output is provided typically as a combination of text and illustrations. OSAVA can visualize a total of twenty-four algorithms (See the table given below).\n   Module Algorithms visualized Illustration Output Pedagogical utility     CPU scheduling algorithms First-come first-served, shortest job first, priority, round robin, multilevel queue and multilevel feedback queue scheduling algorithms Gantt chart Turnaround time, waiting time, response time, throughput and CPU utilization Can be used to solve numerical questions involving large number of processes   Deadlock avoidance algorithm Banker’s algorithm — Safe sequence Can be used to solve numerical questions involving large number of processes and resource types   Deadlock detection algorithm Variant of Banker’s algorithm — List of deadlocked processes Can be used to solve numerical questions involving large number of processes and resource types   Contiguous memory allocation strategies First fit, best fit and worst fit strategies Memory map — Can be used to solve numerical questions involving large number of processes   Page replacement algorithms First-in first-out, optimal, least recently used, second chance, enhanced second chance, least frequently used and most frequently used page replacement algorithms Memory map Number of page faults and page fault ratio Can be used to solve numerical questions involving large number of page faults and frames   Disk scheduling algorithms First-come first-served, shortest seek time first, SCAN, C-SCAN, LOOK and C-LOOK disk scheduling algorithms Trace of the path followed by read/write head Number of cylinders traversed by read/write head Can be used to solve numerical questions involving large number of disk accesses     CPU scheduling algorithms A computer using a multitasking operating system has multiple processes loaded in its memory at a given time. The operating system uses a CPU scheduling algorithm to decide which of those processes will be executed next. OSAVA can visualize the CPU scheduling algorithms commonly used by operating systems. The user has to enter the arrival time and the CPU burst time of the processes. The user then needs to select the CPU scheduling algorithm to be visualized. When shortest job first and priority scheduling algorithms are selected, the user needs to specify whether non-preemptive or preemptive scheduling is to be performed. If priority scheduling is used, then the user also needs to enter the priority of each process. In case of priority scheduling, OSAVA can also visualize the concept of aging in which the priority of a process is incremented every time it waits in the ready queue for a predefined amount of time. If round robin scheduling is used, then the user needs to specify the time quantum. When multilevel queue scheduling and multilevel feedback queue scheduling are selected, then first-come first served and round robin algorithms are used for intra-queue scheduling and preemptive priority scheduling algorithm is used for inter-queue scheduling. Details of the queues are to be entered by the user. Finally, the user has to enter the dispatch latency which is considered to be negligible if the user chooses not to enter a value. OSAVA simulates the selected CPU scheduling algorithm and displays a Gantt chart showing the time intervals when the different processes executed on the CPU. OSAVA then displays a timeline representing the execution of the processes. The turnaround time, waiting time and response time of a particular process can be viewed by tapping on the ‘Details’ button next to it. To calculate the response time of a process, it is assumed that a process generates its first response to the user as soon as it starts executing. The average turnaround time, the average waiting time and the average response time of the processes are then calculated. The throughput of the system and the CPU utilization are also displayed (Fig. 1). OSAVA displays more information about the processes than the earlier tools (Khuri and Hsu 1999; Suranauwarat 2007; Fischbach 2013) but in a more compact format. Deadlock handling algorithms In context of operating systems, a deadlock is a situation where two or more processes are waiting indefinitely because the resources they have requested for are being held by one another. Operating systems may use three techniques to handle deadlocks, viz. deadlock prevention, deadlock avoidance, and deadlock detection and recovery. The Banker’s algorithm is a well known deadlock avoidance technique and can be visualized by OSAVA. The user has to enter the number of resources of different types that have been allocated to the processes and the maximum number of resources of each type that the processes can request for. The user also needs to enter the number of resources of each type that are currently free. Finally, the user needs to specify a process that is now requesting for more resources and enter the number of resources of each type the process is requesting for. It is assumed that the system is initially in a safe state, i.e. there is no possibility of a deadlock. OSAVA uses the resource-request algorithm to determine the state in which the system will be in if the requested resources are granted to the process. Then OSAVA uses the safety algorithm to find a safe sequence, i.e. a sequence in which the processes should be executed so that they can be allocated the resources they need. The matrices and vectors involved in the calculation are displayed to enhance pedagogy. Instead of using the deadlock avoidance algorithm, operating systems may choose to detect deadlocks as they occur and recover from them. The algorithm to detect deadlocks is similar to the Banker’s algorithm and can be visualized by OSAVA as well. The user has to enter the number of resources of different types that have been allocated to the processes and the number of resources of each type that are currently free. The user then needs to enter the number of resources of each type that the processes are now requesting for. OSAVA tries to find a sequence in which the processes can be allocated the resources they are requesting for without causing a deadlock. If such a sequence cannot be found, then OSAVA lists the deadlocked processes.\nMemory management algorithms An operating system may use a contiguous memory allocation scheme wherein a process is loaded in a contiguous block of memory. OSAVA can visualize three common contiguous memory allocation strategies, viz. first fit, best fit and worst fit. The user has to enter the size of the memory, and arrival time, turnaround time and memory requirement of each process. OSAVA then visualizes a memory allocation strategy and displays a map of the memory whenever a process arrives or terminates. Such a memory map shows which parts of the memory are occupied by the different processes and which parts are free (Fig. 2). Most operating systems use pure demand paging to implement virtual memory. Such operating systems must use a page replacement algorithm to select a page to be swapped out from the memory in case of a page fault. The commonly used page replacement algorithms can be visualized by OSAVA. The user has to enter the number of frames in the memory that have been allocated to a process and a reference string. OSAVA then visualizes the selected page replacement algorithm. It shows which page is residing in which frame after each memory access. OSAVA also calculates the total number of page faults and the page fault ratio (Fig. 3). The user interface of OSAVA is simpler and more intuitive to use than those of the earlier tools (Khuri and Hsu 1999; Fischbach 2013; Garmpis 2013) for visualizing page replacement algorithms. Disk scheduling algorithms A hard disk is used as the secondary storage device of a typical computer. Operating systems use an algorithm to schedule the requests to access the different cylinders in the disk in order to decrease the average access time. The common disk scheduling algorithms can be visualized by OSAVA. The user has to enter the number of cylinders in the disk, the current position and the direction of movement of the read/write head. OSAVA simulates a disk scheduling algorithm, and displays a trace of the path followed by the read/write head and the count of cylinders traversed (Fig. 4). Implementation OSAVA has been implemented in Python. It can be downloaded from the Google Play online app store (https://play.google.com/store/apps/details?id=org.nsit.OSAVA\u0026amp;hl=en) and installed on all mobile phones that use the Android operating system. OSAVA is free and open-source (https://github.com/OSAVA-nsit/OSAVA), and does not require connecting to the Internet.\nContribution I implemented the CPU scheduling algorithms. Other contributors include:\n Udit Arora (https://github.com/uditarora) Namrata Mukhija (https://github.com/Namrata96) Priyanka Singla (https://github.com/priyankasingla)  Acknowledgement I would like to thank Prof. Pinaki Chakraborty (http://nsit.ac.in/faculty/pnc/) for the ideas and discussions during the development of OSAVA.\n","date":1524767400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1524767400,"objectID":"448c7becee4b9dbc1283993e3833bad6","permalink":"https://rohit-takhar.github.io/project/osava/","publishdate":"2018-04-27T00:00:00+05:30","relpermalink":"/project/osava/","section":"project","summary":"An application to visualize algorithms used in operating systems.","tags":["Operating Systems","Android","Visualization"],"title":"An application to visualize algorithms used in operating systems","type":"project"},{"authors":[],"categories":null,"content":"Click on the Slides button above to view the built-in slides feature.\n Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using url_slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1483209000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483209000,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://rohit-takhar.github.io/talk/example/","publishdate":"2017-01-01T00:00:00+05:30","relpermalink":"/talk/example/","section":"talk","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam.","tags":[],"title":"Example Talk","type":"talk"},{"authors":null,"categories":null,"content":" Apart from all functionalities of standard FTP, the important thing on which I have worked is to increase the downloading speed of very large files using multithreading(used POSIX threads).\nFor very large files, multiple threads are created and each thread creates an instruction connection and data connection with the server. Each thread downloads a specific chunk of data and then all are combined together to get the file.\nNote: Use only for very large files because creating and managing threads is also an overhead for CPU. Performance will degrade for smaller files.\nFollowing functions are included. For example:\nls : To list files in current directory on server side.\nls -l : Same as ls, with some more details.\npwd : Current working directory on server side.\nget filename : Download file from server.(File should be present on server side).\nput filename : Upload file on server.\nuniqput filename : Uniquely upload file on server.\nmkdir directory_name : Create directory on server.\nrmdir directory_name : Remove directory on server.\nrm filename : Remove file on server.\ncd directory_name : Traverse file system on server side.\nrename old_filename new_filename : Renaming file on server.\n!ls : To list files in current directory on client side.\n!ls -l : Same as !ls, with some more details.\n!pwd : Current working directory on client side.\n!cd directory_name : Traverse file system on client side.\n!mkdir directory_name : Create directory on client side.\n!rmdir directory_name : Remove directory on client side.\nTo run:\nRun command make all to compile program.\nTo execute, run ./myftp server-ip-address.\nEnter user credentials to login on server.\nFeatures in GUI(Apart from all the functionalities)  Drag N Drop to upload and download files.\n Double click to enter directory.\n  Acknowledgements  Professor Khushil Saini(http://nsit.ac.in/faculty/kss/), for the project idea and concepts about multithreading. Stackoverflow community(http://stackoverflow.com). The very helpful documentation of FTP RFC 959(https://www.ietf.org/rfc/rfc959.txt).  ","date":1461695400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461695400,"objectID":"2dc87bc3dfc3242b780d1477c6f92cf3","permalink":"https://rohit-takhar.github.io/project/multi_ftp/","publishdate":"2016-04-27T00:00:00+05:30","relpermalink":"/project/multi_ftp/","section":"project","summary":"Multi-segmented FTP client for Unix based systems.","tags":["Multithreading","C","GTK+"],"title":"Multi-segmented FTP client","type":"project"},{"authors":[],"categories":null,"content":" Academic makes it easy to create a beautiful website for free using Markdown. Customize anything on your site with widgets, themes, and language packs.\n[] [] [] []\nLicense Copyright 2016-present George Cushen.\nReleased under the MIT license.\n","date":1461090600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1515781800,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"https://rohit-takhar.github.io/post/getting-started/","publishdate":"2016-04-20T00:00:00+05:30","relpermalink":"/post/getting-started/","section":"post","summary":"Create a beautifully simple website or blog in under 10 minutes.","tags":["Academic"],"title":"Academic: the website designer for Hugo","type":"post"},{"authors":null,"categories":null,"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c2915ec5da95791851caafdcba9664af","permalink":"https://rohit-takhar.github.io/slides/example-slides/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/slides/example-slides/","section":"slides","summary":"Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$","tags":null,"title":"Slides","type":"slides"}]